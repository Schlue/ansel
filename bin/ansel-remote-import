#!/usr/bin/env php
<?php
/**
* This script allows for adding images to an Ansel install using an RPC
* interface. This script requires Horde's Cli, Rpc, and Argv libraries.
* You will need to make sure that those libraries reside somewhere in
* PHP's include path.
*
* See the enclosed file COPYING for license information (GPL). If you
* did not receive this file, see http://www.fsf.org/copyleft/gpl.html.
*
* @author Michael J. Rubinsky <mrubinsk@horde.org>
*/
if (file_exists(dirname(__FILE__) . '/../../ansel/lib/Application.php')) {
    $baseDir = dirname(__FILE__) . '/../';
} else {
    require_once 'PEAR/Config.php';
    $baseDir = PEAR_Config::singleton()
        ->get('horde_dir', null, 'pear.horde.org') . '/ansel/';
}
require_once $baseDir . 'lib/Application.php';
Horde_Registry::appInit('ansel', array('cli' => true));

$parser = new Horde_Argv_Parser(
    array(
        'usage' => '%prog [--options] remotehost local_directory',
        'optionList' => array(
            new Horde_Argv_Option(
                '-u',
                '--username',
                array(
                    'help' => 'Horde username'
                )
            ),
            new Horde_Argv_Option(
                '-p',
                '--password',
                array(
                    'help' => 'Horde password'
                )
            ),
            new Horde_Argv_Option(
                '-g',
                '--gallery',
                array(
                    'help' => 'The gallery id'
                )
            ),
            new Horde_Argv_Option(
                '-s',
                '--slug',
                array(
                    'help' => 'The gallery slug'
                )
            ),
            new Horde_Argv_Option(
                '-k',
                '--keep',
                array(
                    'default' => false,
                    'action' => 'store_true',
                    'help' => 'Do not delete empty galleries on remote server after export is complete.'
                )
            ),
            new Horde_Argv_Option(
                '-z',
                '--gzip',
                array(
                    'default' => false,
                    'action' => 'store_true',
                    'help' => 'Use gzip compression'
                )
            ),
            new Horde_Argv_Option(
                '-l',
                '--lzf',
                array(
                    'default' => false,
                    'action' => 'store_true',
                    'help' => 'Use lzf compression'
                )
            ),
        )
    )
);

/* Show help and exit if no arguments were set. */
list($opts, $args) = $parser->parseArgs();
if (empty($opts['username']) && empty($opts['password'])) {
    // @TODO: just show usage, not fatal.
    $parser->parserError('Missing Horde credentials.');
}

if (count($args) != 2) {
    $parser->parserError('Need to show usage here.');
}
$rpc_endpoint = $args[0];
$dir = $args[1];
// @TODO: Figure out how to use Horde_Argv to set a single option with this value.
$useCompression = !empty($opts['gzip']) ? 'gzip' : (!empty($opts['lzf']) ? 'lzf' : false);


$rpc_auth = array(
    'request.username' => $opts['username'],
    'request.password' => $opts['password']
);

processDirectory($dir, null, $opts['gallery'], $opts['slug'], $useCompression);

/**
 * Check for, and remove any empty galleries that may have been created during
 * import.
 */
function emptyGalleryCheck($gallery)
{
    if ($gallery->hasSubGalleries()) {
        $children = $GLOBALS['injector']
            ->getInstance('Ansel_Storage')
            ->listGalleries(array('parent' => $gallery->id));
        foreach ($children as $child) {
            // First check all children to see if they are empty...
            emptyGalleryCheck($child);
            if (!$child->countImages() && !$child->hasSubGalleries()) {
                $result = $GLOBALS['injector']->getInstance('Ansel_Storage')->removeGallery($child);
                $GLOBALS['cli']->message(sprintf(_("Deleting empty gallery, \"%s\""), $child->get('name')), 'cli.success');
            }

            // Refresh the gallery values since we mucked around a bit with it
            $gallery = $GLOBALS['injector']->getInstance('Ansel_Storage')->getGallery($gallery->id);
            // Now that any empty children are removed, see if we are empty
            if (!$gallery->countImages() && !$gallery->hasSubGalleries()) {
                $result = $GLOBALS['injector']->getInstance('Ansel_Storage')->removeGallery($gallery);
                $GLOBALS['cli']->message(sprintf(_("Deleting empty gallery, \"%s\""), $gallery->get('name')), 'cli.success');
            }
        }
    }
}

/**
 * Read all images from a directory into the currently selected gallery.
 *
 * @param string $dir          The directory to create a gallery for and import.
 * @param integer $parent      Parent gallery id to attach the new gallery to.
 * @param integer $gallery_id  Start at this gallery_id.
 * @param string  $slug        Same as $gallery_id, except use this slug
 *
 * @return mixed  The gallery_id of the newly created gallery || PEAR_Error
 */
function processDirectory($dir, $parent = null, $gallery_id = null, $slug = null, $compress = 'none')
{
    global $cli, $rpc_auth, $rpc_endpoint;

    $dir = Horde_Util::realPath($dir);
    if (!is_dir($dir)) {
        $cli->fatal(sprintf(_("\"%s\" is not a directory."), $dir));
    }
    $rpc_params = $rpc_auth;
    $language = isset($GLOBALS['language']) ? $GLOBALS['language'] :
            (isset($_SERVER['LANG']) ? $_SERVER['LANG'] : '');
    if (!empty($language)) {
        $rpc_params['request.headers'] = array('Accept-Language' => $language);
    }
    $rpc_params['request.timeout'] = 0;
    $http = $GLOBALS['injector']->getInstance('Horde_Core_Factory_HttpClient')->create($rpc_params);
    /* Create a gallery or use an existing one? */
    if (!empty($gallery_id) || !empty($slug)) {
        /* Start with an existing gallery */
        $method = 'images.getGalleries';
        $params = array(
            is_null($gallery_id) ? null : array($gallery_id),
            null,
            is_null($slug) ? null : array($slug),
        );
        $result = Horde_Rpc::request('jsonrpc', $rpc_endpoint, $method, $http, $params);
        $result = $result->result;
        if (empty($result)) {
            $cli->fatal(sprintf(_("Gallery %s not found."), (empty($slug) ? $gallery_id : $slug)));
        }

        /* Should have only one here, but jsonrpc returns an object, not array */
        foreach ($result as $gallery_info) {
           $name = $gallery_info->attribute_name;
           $gallery_id = $gallery_info->share_id;
        }
        if (empty($name)) {
            $cli->fatal(sprintf(_("Gallery %s not found."), (empty($slug) ? $gallery_id : $slug)));
        }
    } else {
        /* Creating a new gallery */
        $name = basename($dir);
        $cli->message(sprintf(_("Creating gallery: \"%s\""), $name), 'cli.message');
        $method = 'images.createGallery';
        $params = array(array('name' => $name), array('parent' => $parent));
        $result = Horde_Rpc::request('jsonrpc', $rpc_endpoint, $method, $http, $params);
        $gallery_id = $result->result;
        $cli->message(sprintf(_("The gallery \"%s\" was created successfully."), $name), 'cli.success');
    }

    /* Get the files and directories */
    $files = array();
    $directories = array();
    $h = opendir($dir);
    while (false !== ($entry = readdir($h))) {
        if ($entry == '.' ||
            $entry == '..' ||
            $entry == 'Thumbs.db' ||
            $entry == '.DS_Store' ||
            $entry == '.localized' ||
            $entry == '__MACOSX' ||
            strpos($entry, '.') === 1) {
            continue;
        }

        if (is_dir($dir . '/' . $entry)) {
            $directories[] = $entry;
        } else {
            $files[] = $entry;
        }
    }
    closedir($h);

    if ($files) {
        chdir($dir);

        // Process each file and upload to the gallery.
        $added_images = array();
        foreach ($files as $file) {
            $image = getImageFromFile($dir . '/' . $file, $compress);
            $cli->message(sprintf(_("Storing photo \"%s\"..."), $file), 'cli.message');
            $method = 'images.saveImage';
            $params = array(
                $gallery_id,
                $image,
                array(
                    'encoding' => 'binhex',
                    'compression' => $compress));
            try {
                $result = Horde_Rpc::request('jsonrpc', $rpc_endpoint, $method, $http, $params);
            } catch (Horde_Rpc_Exception $e) {
                $cli->fatal(sprintf(_("There was an unspecified error. The server returned: %s"), $e->getMessage()));
            }
            $image_id = $result->result;
            $added_images[] = $file;
        }

        $cli->message(sprintf(ngettext("Successfully added %d photo (%s) to gallery \"%s\" from \"%s\".", "Successfully added %d photos (%s) to gallery \"%s\" from \"%s\".", count($added_images)),
                              count($added_images), join(', ', $added_images), $name, $dir), 'cli.success');
    }

    if ($directories) {
        $cli->message(_("Adding subdirectories:"), 'cli.message');
        foreach ($directories as $directory) {
            processDirectory($dir . '/' . $directory, $gallery_id);
        }
    }

    return $gallery_id;
}

/**
 * Read an image from the filesystem.
 *
 * @param string $file     The filename of the image.
 *
 * @return array  The image data of the file as an array or PEAR_Error
 */
function getImageFromFile($file, $compress = 'none')
{
    if (!file_exists($file)) {
        return PEAR::raiseError(sprintf(_("The file \"%s\" doesn't exist."),
                                $file));
    }

    global $conf, $cli;

    // Get the mime type of the file (and make sure it's an image).
    $mime_type = Horde_Mime_Magic::analyzeFile($file, isset($conf['mime']['magic_db']) ? $conf['mime']['magic_db'] : null);
    if (strpos($mime_type, 'image') === false) {
        return PEAR::raiseError(sprintf(_("Can't get unknown file type \"%s\"."), $file));
    }

    if ($compress == 'gzip' && Horde_Util::loadExtension('zlib')) {
        $data = gzcompress(file_get_contents($file));
    } elseif ($compress == 'gzip') {
        $cli->fatal(_("Could not load the gzip extension"));
    } elseif ($compress == 'lzf' && Horde_Util::loadExtension('lzf')) {
        $data = lzf_compress(file_get_contents($file));
    } elseif ($compress == 'lzf') {
        $cli->fatal(_("Could not load the lzf extension"));
    } else {
        $data = file_get_contents($file);
    }

    $image = array('filename' => basename($file),
                   'description' => '',
                   'type' => $mime_type,
                   'data' => bin2hex($data),
                   );

    return $image;
}



/**
 * Show the command line arguments that the script accepts.
 */
function showHelp()
{
    global $cli;

    $cli->writeln(sprintf(_("Usage: %s [OPTIONS]..."), basename(__FILE__)));
    $cli->writeln();
    $cli->writeln(_("Mandatory arguments to long options are mandatory for short options too."));
    $cli->writeln();
    $cli->writeln(_("-h, --help                   Show this help"));
    $cli->writeln(_("-d, --dir[=directory]        Recursively add all files from the directory, creating\n                             a gallery for each directory"));
    $cli->writeln(_("-u, --username[=username]    Horde login username"));
    $cli->writeln(_("-p, --password[=password]    Horde login password"));
    $cli->writeln(_("-g, --gallery[=gallery_id]   The gallery id to add directory contents to"));
    $cli->writeln(_("-s, --slug[=gallery_slug]    The gallery slug to add directory contents to"));
    //$cli->writeln(_("-k, --keep                   Do not delete empty galleries after import is complete."));
    $cli->writeln(_("-r, --remotehost[=url]       The url of the remote rpc server."));
}
